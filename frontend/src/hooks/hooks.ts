/*
This file is Exports hooks for OpenAPI endpoints using the api client.
It is most certain that this file is not bugged.
Do not edit this file manually.
*/

import { api } from '../lib/openapi';
import { components } from '../types/schema';
import { useState } from 'react';

import type { QuestionRenderView, SaveQuestion, SubmitQuizResponse, QuizSubmissionResponse, FlaggedQuestionResponse, UserQuizMetrics, QuizDetails, QuizAnalytics, QuizPerformance, QuizResults } from '../types/quiz.types';


import type {
  NewAnomalyData,
  AnomalyData,
  DeleteAnomalyBody
} from '@/types/reportanomaly.types';

import type { ProctoringSettings } from '@/types/video.types';
import { InviteBody, InviteResponse, MessageResponse } from '@/types/invite.types';

// Add missing ObjectId type
type ObjectId = string;

// Question types - matching backend validators
export interface QuestionBody {
  question: {
    text: string;
    type: 'SELECT_ONE_IN_LOT' | 'SELECT_MANY_IN_LOT' | 'ORDER_THE_LOTS' | 'NUMERIC_ANSWER_TYPE' | 'DESCRIPTIVE';
    isParameterized: boolean;
    parameters?: Array<{
      name: string;
      possibleValues: string[];
      type: 'number' | 'string';
    }>;
    hint?: string;
    timeLimitSeconds: number;
    points: number;
  };
  solution: any; // Union type based on question type
}

export interface QuestionId {
  questionId: string;
}

export interface QuestionResponse {
  _id: string;
  text: string;
  type: 'SELECT_ONE_IN_LOT' | 'SELECT_MANY_IN_LOT' | 'ORDER_THE_LOTS' | 'NUMERIC_ANSWER_TYPE' | 'DESCRIPTIVE';
  isParameterized: boolean;
  parameters?: Array<{
    name: string;
    possibleValues: string[];
    type: 'number' | 'string';
  }>;
  hint?: string;
  timeLimitSeconds: number;
  points: number;
  // Solution fields based on type
  solutionText?: string;
  decimalPrecision?: number;
  upperLimit?: number;
  lowerLimit?: number;
  value?: number;
  expression?: string;
  ordering?: Array<{
    lotItem: {
      text: string;
      explaination: string;
    };
    order: number;
  }>;
  correctLotItems?: Array<{
    text: string;
    explaination: string;
  }>;
  incorrectLotItems?: Array<{
    text: string;
    explaination: string;
  }>;
  correctLotItem?: {
    text: string;
    explaination: string;
  };
}

export interface FlagQuestionBody {
  reason: string;
  courseId?: string;
  versionId?: string;
}

export interface FlagId {
  flagId: string;
}

export interface ResolveFlagBody {
  status: 'RESOLVED' | 'REJECTED';
}

// Question Bank types - matching backend validators
export interface CreateQuestionBankBody {
  courseId?: string;
  courseVersionId?: string;
  questions?: string[];
  tags?: string[];
  title: string;
  description?: string;
}

export interface CreateQuestionBankResponse {
  questionBankId: string;
}

export interface GetQuestionBankByIdParams {
  questionBankId: string;
}

export interface QuestionBankResponse {
  _id?: string | ObjectId;
  courseId?: string;
  courseVersionId?: string;
  questions?: string[];
  tags?: string[];
  title: string;
  description: string;
}


export interface QuestionBankAndQuestionParams {
  questionBankId: string;
  questionId: string;
}

export interface ReplaceQuestionResponse {
  newQuestionId: string;
}

// Quiz types - matching backend validators
export interface AddQuestionBankBody {
  bankId: string;
  count: number;
  difficulty?: string[];
  tags?: string[];
}

export interface RemoveQuestionBankParams {
  quizId: string;
  questionBankId: string;
}

export interface EditQuestionBankBody {
  bankId: string;
  count: number;
  difficulty?: string[];
  tags?: string[];
}

export interface GetUserMatricesParams {
  quizId: string;
  userId: string;
}

export interface QuizAttemptParam {
  quizId: string;
  attemptId: string;
}

export interface UpdateQuizSubmissionParam {
  quizId: string;
  submissionId: string;
  score: number;
}

export interface RegradeSubmissionBody {
  totalScore?: number;
  totalMaxScore?: number;
  overallFeedback?: Array<{
    questionId: string | ObjectId;
    status: 'CORRECT' | 'INCORRECT' | 'PARTIAL';
    score: number;
    answerFeedback?: string;
  }>;
  gradingStatus: 'PENDING' | 'PASSED' | 'FAILED';
}

export interface AddFeedbackParams {
  quizId: string;
  submissionId: string;
  questionId: string;
}

export interface AddFeedbackBody {
  feedback: string;
}

export interface GetAllQuestionBanksResponse extends Array<{
  bankId: string;
  count: number;
  difficulty?: string[];
  tags?: string[];
  type?: string;
}> {}

// Attempt types - matching backend validators
export interface CreateAttemptParams {
  quizId: string;
}

export interface SaveAttemptParams {
  quizId: string;
  attemptId: string;
}

export interface SubmitAttemptParams {
  quizId: string;
  attemptId: string;
}

export interface QuestionAnswersBody {
  answers: SaveQuestion[];
}

// Updated response types matching backend
export interface CreateAttemptResponse {
  attemptId: string;
  questionRenderViews: QuestionRenderView[];
}

export interface SubmitAttemptResponse {
  totalScore?: number;
  totalMaxScore?: number;
  overallFeedback?: Array<{
    questionId: string | ObjectId;
    status: 'CORRECT' | 'INCORRECT' | 'PARTIAL';
    score: number;
    answerFeedback?: string;
  }>;
  gradingStatus: 'PENDING' | 'PASSED' | 'FAILED' | any;
  gradedAt?: Date;
  gradedBy?: string;
}

export interface UserQuizMetricsResponse {
  _id?: string | ObjectId;
  quizId: string | ObjectId;
  userId: string | ObjectId;
  latestAttemptStatus: 'ATTEMPTED' | 'SUBMITTED';
  latestAttemptId?: string | ObjectId;
  latestSubmissionResultId?: string | ObjectId;
  remainingAttempts: number;
  attempts: Array<{
    attemptId: string | ObjectId;
    submissionResultId?: string | ObjectId;
  }>;
}

export interface QuizAttemptResponse {
  _id?: string | ObjectId;
  quizId: string | ObjectId;
  userId: string | ObjectId;
  questionDetails: Array<{
    questionId: string | ObjectId;
    parameterMap?: Record<string, string | number>;
  }>;
  answers?: Array<{
    questionId: string;
    questionType: 'SELECT_ONE_IN_LOT' | 'SELECT_MANY_IN_LOT' | 'ORDER_THE_LOTS' | 'NUMERIC_ANSWER_TYPE' | 'DESCRIPTIVE';
    answer: any;
  }>;
  createdAt: Date;
  updatedAt: Date;
}

interface IGradingResult {
  totalScore?: number;
  totalMaxScore?: number;
  overallFeedback?: Array<{
    questionId: string | ObjectId;
    status: 'CORRECT' | 'INCORRECT' | 'PARTIAL';
    score: number;
    answerFeedback?: string;
  }>;
  gradingStatus: 'PENDING' | 'PASSED' | 'FAILED' | any;
  gradedAt?: Date;
  gradedBy?: string;
}

export interface QuizSubmissionResponseUpdated {
  _id?: string | ObjectId;
  quizId: string | ObjectId;
  userId: string | ObjectId;
  attemptId: string | ObjectId;
  submittedAt: Date;
  gradingResult?: IGradingResult;
}

// Auth hooks

// POST /auth/verify
export function useLogin(): {
  data: components['schemas']['TokenVerificationResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("post", "/auth/verify", {});

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Login failed') : null,
    refetch: result.refetch
  };
}

// POST /auth/google
export function useLoginWithGoogle(): {
  mutate: (variables: { body: { lastName: string, firstName: string, email: string } }) => void,
  mutateAsync: (variables: { body: { lastName: string, firstName: string, email: string } }) => Promise<components['schemas']['SignUpResponse']>,
  data: components['schemas']['TokenVerificationResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/auth/google");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Google login failed') : null
  };
}

// POST /auth/signup
export function useSignup(): {
  mutate: (variables: { body: components['schemas']['SignUpBody'] }) => void,
  mutateAsync: (variables: { body: components['schemas']['SignUpBody'] }) => Promise<components['schemas']['SignUpResponse']>,
  data: components['schemas']['SignUpResponse'] | undefined,
  error: unknown | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/auth/signup");
  return {
    ...result,
    error: result.error ? (result.error) : null
  };
}

// POST /auth/signup/verify
export function useVerifySignUpProvider(): {
  mutate: (variables: { body: components['schemas']['VerifySignUpProviderBody'] }) => void,
  mutateAsync: (variables: { body: components['schemas']['VerifySignUpProviderBody'] }) => Promise<components['schemas']['SignUpResponse']>,
  data: components['schemas']['SignUpResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/auth/signup/verify");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Verification failed') : null
  };
}

// PATCH /auth/change-password
export function useChangePassword(): {
  mutate: (variables: { body: components['schemas']['ChangePasswordBody'] }) => void,
  mutateAsync: (variables: { body: components['schemas']['ChangePasswordBody'] }) => Promise<components['schemas']['ChangePasswordResponse']>,
  data: components['schemas']['ChangePasswordResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("patch", "/auth/change-password");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Password change failed') : null
  };
}

// Course hooks

// POST /courses/
export function useCreateCourse(): {
  mutate: (variables: { body: components['schemas']['CreateCourseBody'] }) => void,
  mutateAsync: (variables: { body: components['schemas']['CreateCourseBody'] }) => Promise<components['schemas']['CourseDataResponse']>,
  data: components['schemas']['CourseDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/courses/");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Course creation failed') : null
  };
}

export async function useProcessInvites(inviteId: string): Promise<{
  data: null,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
}> {
  let isLoading = true;
  const method = 'GET';
  const url = `${import.meta.env.VITE_BASE_URL}/notifications/invite/${inviteId}`;

  const res = await fetch(url, {
    method,
    headers: { 'Content-Type': 'application/json', 'authorization': `Bearer ${localStorage.getItem('firebase-auth-token')}` },
  });

  isLoading = false;

  if (!res.ok) {
    throw new Error(`Failed to update settings: ${res.status}`);
  }

  console.log(res);

  return {
    data: null,
    isLoading: isLoading,
    error: "",
    refetch: () => { }
  }
}

// GET /courses/{id}
export function useCourseById(id: string): {
  data: components['schemas']['CourseDataResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/courses/{id}", {
    params: { path: { id } }
  }, { enabled: !!id });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch course') : null,
    refetch: result.refetch
  };
}

// PUT /courses/{id}
export function useUpdateCourse(): {
  mutate: (variables: { params: { path: { id: string } }, body: components['schemas']['UpdateCourseBody'] }) => void,
  mutateAsync: (variables: { params: { path: { id: string } }, body: components['schemas']['UpdateCourseBody'] }) => Promise<components['schemas']['CourseDataResponse']>,
  data: components['schemas']['CourseDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/courses/{id}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Course update failed') : null
  };
}

// DELETE /courses/{id}
export function useDeleteCourse(): {
  mutate: (variables: { params: { path: { id: string } } }) => void,
  mutateAsync: (variables: { params: { path: { id: string } } }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/courses/{id}");

  return {
    ...result,
    error: result.error ? (result.error || 'Failed to delete course') : null
  };
}


// Course Version hooks

// POST /courses/{id}/versions
export function useCreateCourseVersion(): {
  mutate: (variables: { params: { path: { id: string } }, body: components['schemas']['CreateCourseVersionBody'] }) => void,
  mutateAsync: (variables: { params: { path: { id: string } }, body: components['schemas']['CreateCourseVersionBody'] }) => Promise<components['schemas']['CreateCourseVersionResponse']>,
  data: components['schemas']['CreateCourseVersionResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/courses/{id}/versions");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Course version creation failed') : null
  };
}

// GET /courses/versions/{id}
export function useCourseVersionById(id: string): {
  data: components['schemas']['CourseVersionDataResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/courses/versions/{id}", {
    params: { path: { id } }
  }, { enabled: !!id }
  );

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch course version') : null,
    refetch: result.refetch
  };
}

// DELETE /courses/{courseId}/versions/{versionId}
export function useDeleteCourseVersion(): {
  mutate: (variables: { params: { path: { courseId: string, versionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { courseId: string, versionId: string } } }) => Promise<components['schemas']['DeleteCourseVersionParams']>,
  data: components['schemas']['DeleteCourseVersionParams'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/courses/{courseId}/versions/{versionId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Course version deletion failed') : null
  };
}

// Module hooks

// POST /courses/versions/{versionId}/modules
export function useCreateModule(): {
  mutate: (variables: { params: { path: { versionId: string } }, body: components['schemas']['CreateModuleBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string } }, body: components['schemas']['CreateModuleBody'] }) => Promise<components['schemas']['ModuleDataResponse']>,
  data: components['schemas']['ModuleDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/courses/versions/{versionId}/modules");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Module creation failed') : null
  };
}

// PUT /courses/versions/{versionId}/modules/{moduleId}
export function useUpdateModule(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string } }, body: components['schemas']['UpdateModuleBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string } }, body: components['schemas']['UpdateModuleBody'] }) => Promise<components['schemas']['ModuleDataResponse']>,
  data: components['schemas']['ModuleDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/courses/versions/{versionId}/modules/{moduleId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Module update failed') : null
  };
}

// DELETE /courses/versions/{versionId}/modules/{moduleId}
export function useDeleteModule(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string } } }) => Promise<components['schemas']['ModuleDeletedResponse']>,
  data: components['schemas']['ModuleDeletedResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/courses/versions/{versionId}/modules/{moduleId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Module deletion failed') : null
  };
}

// PUT /courses/versions/{versionId}/modules/{moduleId}/move
export function useMoveModule(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string } }, body: components['schemas']['MoveModuleBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string } }, body: components['schemas']['MoveModuleBody'] }) => Promise<components['schemas']['ModuleDataResponse']>,
  data: components['schemas']['ModuleDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/courses/versions/{versionId}/modules/{moduleId}/move");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Module move failed') : null
  };
}

// Section hooks

// POST /courses/versions/{versionId}/modules/{moduleId}/sections
export function useCreateSection(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string } }, body: components['schemas']['CreateSectionBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string } }, body: components['schemas']['CreateSectionBody'] }) => Promise<components['schemas']['SectionDataResponse']>,
  data: components['schemas']['SectionDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/courses/versions/{versionId}/modules/{moduleId}/sections");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Section creation failed') : null
  };
}

// PUT /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}
export function useUpdateSection(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } }, body: components['schemas']['UpdateSectionBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } }, body: components['schemas']['UpdateSectionBody'] }) => Promise<components['schemas']['SectionDataResponse']>,
  data: components['schemas']['SectionDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Section update failed') : null
  };
}

// DELETE /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}
export function useDeleteSection(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } } }) => Promise<components['schemas']['SectionDeletedResponse']>,
  data: components['schemas']['SectionDeletedResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Section deletion failed') : null
  };
}

// PUT /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/move
export function useMoveSection(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } }, body: components['schemas']['MoveSectionBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } }, body: components['schemas']['MoveSectionBody'] }) => Promise<components['schemas']['SectionDataResponse']>,
  data: components['schemas']['SectionDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/move");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Section move failed') : null
  };
}

// Item hooks

// GET /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items
export function useItemsBySectionId(versionId: string, moduleId: string, sectionId: string): {
  data: components['schemas']['ItemDataResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items", {
    params: { path: { versionId, moduleId, sectionId } }
  }, { enabled: !!versionId && !!moduleId && !!sectionId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch items') : null,
    refetch: result.refetch
  };
}

// POST /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items
export function useCreateItem(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } }, body: components['schemas']['CreateItemBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string } }, body: components['schemas']['CreateItemBody'] }) => Promise<components['schemas']['ItemDataResponse']>,
  data: components['schemas']['ItemDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Item creation failed') : null
  };
}

// GET /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items/{itemId}
export function useItemById(courseId: string, versionId: string, itemId: string): {
  data: components['schemas']['ItemDataResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/courses/{courseId}/versions/{versionId}/item/{itemId}", {
    params: { path: { courseId, versionId, itemId } }
  }, { enabled: !!courseId && !!versionId && !!itemId }
  );
  // console.log("here", courseId , versionId , itemId);
  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message ? result.error.message : "ERROR HERE") : null,
    refetch: result.refetch
  };
}

// PUT /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items/{itemId}
export function useUpdateItem(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string, itemId: string } }, body: components['schemas']['UpdateItemBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string, itemId: string } }, body: components['schemas']['UpdateItemBody'] }) => Promise<components['schemas']['ItemDataResponse']>,
  data: components['schemas']['ItemDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items/{itemId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Item update failed') : null
  };
}

// DELETE /courses/itemGroups/{itemsGroupId}/items/{itemId}
export function useDeleteItem(): {
  mutate: (variables: { params: { path: { itemsGroupId: string, itemId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { itemsGroupId: string, itemId: string } } }) => Promise<components['schemas']['DeletedItemResponse']>,
  data: components['schemas']['DeletedItemResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/courses/itemGroups/{itemsGroupId}/items/{itemId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Item deletion failed') : null
  };
}

// PUT /courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items/{itemId}/move
export function useMoveItem(): {
  mutate: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string, itemId: string } }, body: components['schemas']['MoveItemBody'] }) => void,
  mutateAsync: (variables: { params: { path: { versionId: string, moduleId: string, sectionId: string, itemId: string } }, body: components['schemas']['MoveItemBody'] }) => Promise<components['schemas']['ItemDataResponse']>,
  data: components['schemas']['ItemDataResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/courses/versions/{versionId}/modules/{moduleId}/sections/{sectionId}/items/{itemId}/move");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Item move failed') : null
  };
}

// Enrollment hooks

// POST /users/enrollments/courses/{courseId}/versions/{courseVersionId}
export function useEnrollUser(): {
  mutate: (variables: { params: { path: { courseId: string, courseVersionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { courseId: string, courseVersionId: string } } }) => Promise<components['schemas']['EnrollUserResponseData']>,
  data: components['schemas']['EnrollUserResponseData'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/users/enrollments/courses/{courseId}/versions/{courseVersionId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'User enrollment failed') : null
  };
}

// POST /users/{userId}/enrollments/courses/{courseId}/versions/{courseVersionId}/unenroll
export function useUnenrollUser(): {
  mutate: (variables: { params: { path: { userId: string, courseId: string, courseVersionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { userId: string, courseId: string, courseVersionId: string } } }) => Promise<components['schemas']['EnrollUserResponseData']>,
  data: components['schemas']['EnrollUserResponseData'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/users/{userId}/enrollments/courses/{courseId}/versions/{courseVersionId}/unenroll");
  return {
    ...result,
    error: result.error ? (result.error.message || 'User unenrollment failed') : null
  };
}

// GET /users/enrollments
export function useUserEnrollments(page?: number, limit?: number, enabled: boolean = true): {
  data: components['schemas']['EnrollmentResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/users/enrollments", {
    params: {
      query: { page, limit }
    },
    enabled: enabled
  });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch user enrollments') : null,
    refetch: result.refetch
  };
}

// GET /enrollments/courses/{courseId}/versions/{courseVersionId}
export function useCourseVersionEnrollments(courseId: string | undefined, courseVersionId: string | undefined, page?: number, limit?: number, enabled: boolean = true): {
  data: components['schemas']['CourseVersionEnrollmentResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/users/enrollments/courses/{courseId}/versions/{courseVersionId}", {
    params: {
      path: { courseId, courseVersionId },
      query: { page, limit }
    },
    enabled: enabled && !!courseId && !!courseVersionId
  });
  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch course version enrollments') : null,
    refetch: result.refetch
  };
}

// Progress hooks

// GET /users/progress/courses/{courseId}/versions/{courseVersionId}/
export function useUserProgress(courseId: string, courseVersionId: string): {
  data: components['schemas']['ProgressDataResponse'] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/users/progress/courses/{courseId}/versions/{courseVersionId}/", {
    params: { path: { courseId, courseVersionId } }
  }, { enabled: !!courseId && !!courseVersionId }
  );

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch user progress') : null,
    refetch: result.refetch
  };
}

// GET /users/progress/courses/{courseId}/versions/{courseVersionId}/percentage
export function useUserProgressPercentage(courseId: string, courseVersionId: string): {
  data: {
    completed: boolean;
    percentCompleted: number;
    totalItems: number;
    completedItems: number;
  } | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/users/progress/courses/{courseId}/versions/{courseVersionId}/percentage", {
    params: { path: { courseId, courseVersionId } }
  }, { enabled: !!courseId && !!courseVersionId }
  );

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch user progress percentage') : null,
    refetch: result.refetch
  };
}

// Add this hook to your hooks file
export function useUserProgressPercentageByUserId(
  userId: string,
  courseId: string,
  courseVersionId: string
): {
  data: {
    completed: boolean;
    percentCompleted: number;
    totalItems: number;
    completedItems: number;
  } | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery(
    "get",
    "/users/{userId}/progress/courses/{courseId}/versions/{courseVersionId}/percentage",
    {
      params: {
        path: {
          userId,
          courseId,
          courseVersionId
        }
      }
    },
    {
      enabled: !!(userId && courseId && courseVersionId)
    }
  );

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch user progress percentage') : null,
    refetch: result.refetch
  };
}

// POST /users/progress/courses/{courseId}/versions/{courseVersionId}/start
export function useStartItem(): {
  mutate: (variables: { params: { path: { courseId: string, courseVersionId: string } }, body: components['schemas']['StartItemBody'] }) => void,
  mutateAsync: (variables: { params: { path: { courseId: string, courseVersionId: string } }, body: components['schemas']['StartItemBody'] }) => Promise<components['schemas']['StartItemResponse']>,
  data: components['schemas']['StartItemResponse'] | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/users/progress/courses/{courseId}/versions/{courseVersionId}/start");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to start item') : null
  };
}

// POST /users/progress/courses/{courseId}/versions/{courseVersionId}/stop
export function useStopItem(): {
  mutate: (variables: { params: { path: { courseId: string, courseVersionId: string } }, body: components['schemas']['StopItemBody'] }) => void,
  mutateAsync: (variables: { params: { path: { courseId: string, courseVersionId: string } }, body: components['schemas']['StopItemBody'] }) => Promise<unknown>,
  data: unknown | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/users/progress/courses/{courseId}/versions/{courseVersionId}/stop");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to stop item') : null
  };
}

// PATCH /users/{userid}/progress/courses/{courseId}/versions/{courseVersionId}/reset
export function useResetProgress(): {
  mutate: (variables: { params: { path: { userId: string, courseId: string, courseVersionId: string } }, body: components['schemas']['ResetCourseProgressBody'] }) => void,
  mutateAsync: (variables: { params: { path: { userId: string, courseId: string, courseVersionId: string } }, body: components['schemas']['ResetCourseProgressBody'] }) => Promise<unknown>,
  data: unknown | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("patch", "/users/{userId}/progress/courses/{courseId}/versions/{courseVersionId}/reset");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to reset progress') : null
  };
}

export function useProctoringSettings(courseId: string, versionId: string): {
  data: ProctoringSettings | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/setting/course-setting/{courseId}/{versionId}", {
    params: { path: { courseId, versionId } }
  },
    { enabled: !!courseId && !!versionId }
  );

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch user by Firebase UID') : null,
    refetch: result.refetch
  };
}

export function useEditProctoringSettings() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const editSettings = async (
    courseId: string,
    versionId: string,
    detectors: { name: string; enabled: boolean }[],
    isNew: boolean
  ) => {
    setLoading(true);
    setError(null);

    try {
      const method = 'PUT';
      const url = `${import.meta.env.VITE_BASE_URL}/setting/course-setting/${courseId}/${versionId}/proctoring`;

      const body =
      {
        detectors: detectors.map((d) => ({
          detectorName: d.name,
          settings: { enabled: d.enabled },
        })),
      };

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json', 'authorization': `Bearer ${localStorage.getItem('firebase-auth-token')}` },
        body: JSON.stringify(body),
      });

      console.log('Proctoring settings response:', res);

      if (!res.ok) {
        throw new Error(`Failed to update settings: ${res.status}`);
      }

      return await res.json();
    } catch (err: any) {
      setError(err.message || 'Unknown error');
    } finally {
      setLoading(false);
    }
  };

  return { editSettings, loading, error };
}

export function useInviteUsers(): {
  mutate: (variables: { params: { path: { courseId: string, courseVersionId: string } }, body: InviteBody }) => void,
  mutateAsync: (variables: { params: { path: { courseId: string, courseVersionId: string } }, body: InviteBody }) => Promise<InviteResponse>,
  data: InviteResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/notifications/invite/courses/{courseId}/versions/{courseVersionId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to invite users') : null
  };
}

export function useCourseInvites(courseId: string, courseVersionId: string, enabled: boolean = true): {
  data: InviteResponse | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/notifications/invite/courses/{courseId}/versions/{courseVersionId}", {
    params: { path: { courseId, courseVersionId } },
    enabled: enabled
  });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch course invites') : null,
    refetch: result.refetch
  };
}

export function useResendInvite(): {
  mutate: (variables: { params: { path: { inviteId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { inviteId: string } } }) => Promise<MessageResponse>,
  data: MessageResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/notifications/invite/resend/{inviteId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to resend invite') : null
  };
}

export function useCancelInvite(): {
  mutate: (variables: { params: { path: { inviteId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { inviteId: string } } }) => Promise<MessageResponse>,
  data: MessageResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/notifications/invite/cancel/{inviteId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to cancel invite') : null
  };
}

// GET /users/{id}/watchTime/item/itemId
export function useWatchTimeByItemId(userId: string, courseId: string, courseVersionId: string, itemId: string, type: string): {
  data: undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/users/{id}/watchTime/course/{courseId}/version/{courseVersionId}/item/{itemId}/type/{type}", {
    params: { path: { id: userId, courseId: courseId, courseVersionId: courseVersionId, itemId: itemId, type: type } },
  }, { enabled: !!userId && !!itemId && !!type },);

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch watch time') : null,
    refetch: result.refetch
  };
}

export function useEditUser(): {
  mutate: (variables: { body: { firstName?: string; lastName?: string } }) => void,
  mutateAsync: (variables: { body: { firstName?: string; lastName?: string } }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("patch", "/users/edit");

  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to edit user') : null
  };
}

export function useWatchtimeTotal(): {
  data: number | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/users/watchTime/total");

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch total watch time') : null,
    refetch: result.refetch
  };
}


// --- AnomalyController Hooks ---

// POST /anomalies/record/image
export function useReportAnomalyImage(): {
  mutate: (variables: { body: NewAnomalyData; file: File }) => void,
  mutateAsync: (variables: { body: NewAnomalyData; file: File }) => Promise<AnomalyData>,
  data: AnomalyData | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  // This assumes api.useMutation supports multipart/form-data
  const result = api.useMutation("post", "/anomalies/record/image", { isMultipart: true });
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to record anomaly image') : null
  };
}

// POST /anomalies/record/audio
export function useReportAnomalyAudio(): {
  mutate: (variables: { body: NewAnomalyData; file: File }) => void,
  mutateAsync: (variables: { body: NewAnomalyData; file: File }) => Promise<AnomalyData>,
  data: AnomalyData | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  // This assumes api.useMutation supports multipart/form-data
  const result = api.useMutation("post", "/anomalies/record/audio", { isMultipart: true });
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to record anomaly audio') : null
  };
}

// GET /anomalies/course/:courseId/version/:versionId/user/:userId
export function useUserAnomalies(courseId: string, versionId: string, userId: string): {
  data: AnomalyData[] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery(
    "get",
    "/anomalies/course/{courseId}/version/{versionId}/user/{userId}",
    { params: { path: { courseId, versionId, userId } } },
    { enabled: !!courseId && !!versionId && !!userId }
  );
  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch user anomalies') : null,
    refetch: result.refetch
  };
}

// GET /anomalies/course/:courseId/version/:versionId
export function useCourseAnomalies(courseId: string, versionId: string): {
  data: AnomalyData[] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery(
    "get",
    "/anomalies/course/{courseId}/version/{versionId}",
    { params: { path: { courseId, versionId } } },
    { enabled: !!courseId && !!versionId }
  );
  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch course anomalies') : null,
    refetch: result.refetch
  };
}

// DELETE /anomalies/:id
export function useDeleteAnomaly(): {
  mutate: (variables: { params: { path: { id: string } }, body: DeleteAnomalyBody }) => void,
  mutateAsync: (variables: { params: { path: { id: string } }, body: DeleteAnomalyBody }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/anomalies/{id}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to delete anomaly') : null
  };
}

export interface QuestionId {
  questionId: string;
}

export interface QuestionResponse {
  _id: string;
  type: string;
  details: any;
  createdBy: string;
  createdAt: string;
  updatedAt: string;
}

export interface FlagQuestionBody {
  reason: string;
  courseId: string;
  versionId: string;
}

export interface FlagId {
  flagId: string;
}

export interface ResolveFlagBody {
  status: 'resolved' | 'rejected';
}

// Question Bank types
export interface CreateQuestionBankBody {
  courseId?: string;
  courseVersionId?: string;
  questions?: string[];
  tags?: string[];
  title: string;
  description?: string;
}

export interface CreateQuestionBankResponse {
  questionBankId: string;
}

export interface GetQuestionBankByIdParams {
  questionBankId: string;
}

export interface QuestionBankAndQuestionParams {
  questionBankId: string;
  questionId: string;
}

export interface ReplaceQuestionResponse {
  newQuestionId: string;
}

export interface RemoveQuestionBankParams {
  quizId: string;
  questionBankId: string;
}

export interface EditQuestionBankBody {
  questionBankId: string;
  questionsCount?: number;
}

export interface GetUserMatricesParams {
  quizId: string;
  userId: string;
}

export interface QuizAttemptParam {
  quizId: string;
  attemptId: string;
}

export interface UpdateQuizSubmissionParam {
  quizId: string;
  submissionId: string;
  score: number;
}

export interface RegradeSubmissionBody {
  gradingResult: any;
}

export interface AddFeedbackParams {
  quizId: string;
  submissionId: string;
  questionId: string;
}

export interface AddFeedbackBody {
  feedback: string;
}

export interface GetAllQuestionBanksResponse extends Array<{
    questionBankId: string;
    questionsCount?: number;
  }> {}

// Attempt types
export interface CreateAttemptParams {
  quizId: string;
}

export interface SaveAttemptParams {
  quizId: string;
  attemptId: string;
}

export interface SubmitAttemptParams {
  quizId: string;
  attemptId: string;
}

export interface QuestionAnswersBody {
  answers: SaveQuestion[];
}

// --- Question Controller Hooks ---
// Quiz hooks
export function useAttemptQuiz(): {
  mutate: (variables: { params: { path: { quizId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string } } }) => Promise<CreateAttemptResponse>,
  data: CreateAttemptResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/{quizId}/attempt")
  return {
    mutate: result.mutate,
    mutateAsync: result.mutateAsync,
    data: result.data,
    isPending: result.isPending,
    isSuccess: result.isSuccess,
    isError: result.isError,
    isIdle: result.isIdle,
    reset: result.reset,
    status: result.status,
    error: result.error ? (result.error.message || 'Failed to attempt quiz') : null
  };
}

export function useFlagQuestion(): {
  mutate: (variables: { params: { path: { questionId: string } }, body: components['schemas']['FlagQuestionBody'] }) => void,
  mutateAsync: (variables: { params: { path: { questionId: string } }, body: components['schemas']['FlagQuestionBody'] }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/questions/{questionId}/flag");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to flag question') : null
  };
}


export function useSaveQuiz(): {
  mutate: (variables: { params: { path: { quizId: string, attemptId: string } }, body: { answers: SaveQuestion[] } }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string, attemptId: string } }, body: { answers: SaveQuestion[] } }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/{quizId}/attempt/{attemptId}/save");
  return {
    mutate: result.mutate,
    mutateAsync: result.mutateAsync,
    data: result.data,
    isPending: result.isPending,
    isSuccess: result.isSuccess,
    isError: result.isError,
    isIdle: result.isIdle,
    reset: result.reset,
    status: result.status,
    error: result.error ? (result.error.message || 'Failed to save quiz') : null
  };
}

export function useSubmitQuiz(): {
  mutate: (variables: { params: { path: { quizId: string, attemptId: string } }, body: { answers: SaveQuestion[] } }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string, attemptId: string } }, body: { answers: SaveQuestion[] } }) => Promise<SubmitAttemptResponse>,
  data: SubmitAttemptResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/{quizId}/attempt/{attemptId}/submit");
  return {
    mutate: result.mutate,
    mutateAsync: result.mutateAsync,
    data: result.data,
    isPending: result.isPending,
    isSuccess: result.isSuccess,
    isError: result.isError,
    isIdle: result.isIdle,
    reset: result.reset,
    status: result.status,
    error: result.error ? (result.error.message || 'Failed to submit quiz') : null
  };
}

interface IAttemptDetails {
  attemptId: string | ObjectId;
  submissionResultId?: string | ObjectId;
}

// GET /quizzes/{quizId}/user/{userId}
export function useUserQuizMetrics(quizId: string, userId: string): {
  data: UserQuizMetricsResponse | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/user/{userId}", {
    params: { path: { quizId, userId } }
  }, { enabled: !!quizId && !!userId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message ? result.error.message : "ERROR HERE") : null,
    refetch: result.refetch
  };
}

// GET /quiz/{quizId}/submissions/{submissionId}
export function useQuizSubmission(quizId: string, submissionId: string): {
  data: QuizSubmissionResponseUpdated | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/submissions/{submissionId}", {
    params: { path: { quizId, submissionId } }
  }, { enabled: !!quizId && !!submissionId }
  );

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message ? result.error.message : "Cannot fetch Quiz submission details.") : null,
    refetch: result.refetch
  };
}


// GET /quizzes/questions/{questionId}
export function useQuestionById(questionId: string): {
  data: QuestionResponse | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/questions/{questionId}", {
    params: { path: { questionId } }
  }, { enabled: !!questionId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch question') : null,
    refetch: result.refetch
  };
}

// POST /quizzes/questions
export function useCreateQuestion(): {
  mutate: (variables: { body: QuestionBody }) => void,
  mutateAsync: (variables: { body: QuestionBody }) => Promise<{ questionId: string }>,
  data: { questionId: string } | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/questions");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Question creation failed') : null
  };
}

// PUT /quizzes/questions/{questionId}
export function useUpdateQuestion(): {
  mutate: (variables: { params: { path: { questionId: string } }, body: QuestionBody }) => void,
  mutateAsync: (variables: { params: { path: { questionId: string } }, body: QuestionBody }) => Promise<QuestionResponse>,
  data: QuestionResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("put", "/quizzes/questions/{questionId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Question update failed') : null
  };
}

// DELETE /quizzes/questions/{questionId}
export function useDeleteQuestion(): {
  mutate: (variables: { params: { path: { questionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { questionId: string } } }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/quizzes/questions/{questionId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Question deletion failed') : null
  };
}

// POST /quizzes/questions/flags/{flagId}/resolve
export function useResolveFlaggedQuestion(): {
  mutate: (variables: { params: { path: { flagId: string } }, body: ResolveFlagBody }) => void,
  mutateAsync: (variables: { params: { path: { flagId: string } }, body: ResolveFlagBody }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/questions/flags/{flagId}/resolve");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to resolve flagged question') : null
  };
}

// --- Question Bank Controller Hooks ---

// POST /quizzes/question-bank
export function useCreateQuestionBank(): {
  mutate: (variables: { body: CreateQuestionBankBody }) => void,
  mutateAsync: (variables: { body: CreateQuestionBankBody }) => Promise<CreateQuestionBankResponse>,
  data: CreateQuestionBankResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/question-bank");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Question bank creation failed') : null
  };
}

// GET /quizzes/question-bank/{questionBankId}
export function useQuestionBankById(questionBankId: string): {
  data: QuestionBankResponse | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/question-bank/{questionBankId}", {
    params: { path: { questionBankId } }
  }, { enabled: !!questionBankId && questionBankId !== '' });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch question bank') : null,
    refetch: result.refetch
  };
}

// PATCH /quizzes/question-bank/{questionBankId}/questions/{questionId}/add
export function useAddQuestionToBank(): {
  mutate: (variables: { params: { path: { questionBankId: string, questionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { questionBankId: string, questionId: string } } }) => Promise<QuestionBankResponse>,
  data: QuestionBankResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("patch", "/quizzes/question-bank/{questionBankId}/questions/{questionId}/add");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to add question to bank') : null
  };
}

// PATCH /quizzes/question-bank/{questionBankId}/questions/{questionId}/remove
export function useRemoveQuestionFromBank(): {
  mutate: (variables: { params: { path: { questionBankId: string, questionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { questionBankId: string, questionId: string } } }) => Promise<QuestionBankResponse>,
  data: QuestionBankResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("patch", "/quizzes/question-bank/{questionBankId}/questions/{questionId}/remove");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to remove question from bank') : null
  };
}

// PATCH /quizzes/question-bank/{questionBankId}/questions/{questionId}/replace-duplicate
export function useReplaceQuestionWithDuplicate(): {
  mutate: (variables: { params: { path: { questionBankId: string, questionId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { questionBankId: string, questionId: string } } }) => Promise<ReplaceQuestionResponse>,
  data: ReplaceQuestionResponse | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("patch", "/quizzes/question-bank/{questionBankId}/questions/{questionId}/replace-duplicate");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to replace question with duplicate') : null
  };
}

// --- Quiz Controller Hooks ---

// POST /quizzes/quiz/{quizId}/bank
export function useAddQuestionBankToQuiz(): {
  mutate: (variables: { params: { path: { quizId: string } }, body: AddQuestionBankBody }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string } }, body: AddQuestionBankBody }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/quiz/{quizId}/bank");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to add question bank to quiz') : null
  };
}

export function useGetProcotoringSettings(): {
  getSettings: (courseId: string, courseVersionId: string) => Promise<any>;
  settingLoading: boolean;
  settingError: string | null;
} {
  const [settingLoading, setSettingLoading] = useState(false);
  const [settingError, setSettingError] = useState<string | null>(null);

  const getSettings = async (
    courseId: string,
    courseVersionId: string
  ): Promise<any> => {
    setSettingLoading(true);
    setSettingError(null);

    try {
      const method = 'GET';
      const url = `${import.meta.env.VITE_BASE_URL}/setting/course-setting/${courseId}/${courseVersionId}/`;

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json', 'authorization': `Bearer ${localStorage.getItem('firebase-auth-token')}` },
      });

      if (!res.ok) {
        throw new Error(`Failed to update settings: ${res.status}`);
      }

      return await res.json();
    } catch (err: any) {
      setSettingError(err.message || 'Unknown error');
    } finally {
      setSettingLoading(false);
    }
  };

  return { getSettings, settingLoading, settingError };
}

export function useInvites(): {
  getInvites: () => Promise<any>;
  loading: boolean;
  error: string | null;
} {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getInvites = async (): Promise<any> => {
    setLoading(true);
    setError(null);

    try {
      const method = 'GET';
      const url = `${import.meta.env.VITE_BASE_URL}/notifications/invite/`;

      const res = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json', 'authorization': `Bearer ${localStorage.getItem('firebase-auth-token')}` },
      });

      console.log(res);

      if (!res.ok) {
        throw new Error(`Failed to update settings: ${res.status}`);
      }

      return await res.json();
    } catch (err: any) {
      setError(err.message || 'Unknown error');
    } finally {
      setLoading(false);
    }
  };

  return { getInvites, loading, error };
}

// DELETE /quizzes/quiz/{quizId}/bank/{questionBankId}
export function useRemoveQuestionBankFromQuiz(): {
  mutate: (variables: { params: { path: { quizId: string, questionBankId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string, questionBankId: string } } }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("delete", "/quizzes/quiz/{quizId}/bank/{questionBankId}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to remove question bank from quiz') : null
  };
}

// PATCH /quizzes/quiz/{quizId}/bank
export function useEditQuestionBankInQuiz(): {
  mutate: (variables: { params: { path: { quizId: string } }, body: EditQuestionBankBody }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string } }, body: EditQuestionBankBody }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("patch", "/quizzes/quiz/{quizId}/bank");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to edit question bank configuration') : null
  };
}

// GET /quizzes/quiz/{quizId}/bank
export function useGetAllQuestionBanksForQuiz(quizId: string): {
  data: GetAllQuestionBanksResponse | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/bank", {
    params: { path: { quizId } }
  }, { enabled: !!quizId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch question banks for quiz') : null,
    refetch: result.refetch
  };
}

// POST /quizzes/quiz/{quizId}/submission/{submissionId}/score/{score}
export function useUpdateQuizSubmissionScore(): {
  mutate: (variables: { params: { path: { quizId: string, submissionId: string, score: number } } }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string, submissionId: string, score: number } } }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/quiz/{quizId}/submission/{submissionId}/score/{score}");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to update submission score') : null
  };
}

// POST /quizzes/quiz/{quizId}/submission/{submissionId}/regrade
export function useRegradeQuizSubmission(): {
  mutate: (variables: { params: { path: { quizId: string, submissionId: string } }, body: RegradeSubmissionBody }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string, submissionId: string } }, body: RegradeSubmissionBody }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/quiz/{quizId}/submission/{submissionId}/regrade");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to regrade submission') : null
  };
}

// POST /quizzes/quiz/{quizId}/submission/{submissionId}/question/{questionId}/feedback
export function useAddFeedbackToQuizQuestion(): {
  mutate: (variables: { params: { path: { quizId: string, submissionId: string, questionId: string } }, body: AddFeedbackBody }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string, submissionId: string, questionId: string } }, body: AddFeedbackBody }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/quiz/{quizId}/submission/{submissionId}/question/{questionId}/feedback");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to add feedback to question') : null
  };
}

// POST /quizzes/quiz/{quizId}/user/{userId}/reset-attempts
export function useResetUserQuizAttempts(): {
  mutate: (variables: { params: { path: { quizId: string, userId: string } } }) => void,
  mutateAsync: (variables: { params: { path: { quizId: string, userId: string } } }) => Promise<void>,
  data: void | undefined,
  error: string | null,
  isPending: boolean,
  isSuccess: boolean,
  isError: boolean,
  isIdle: boolean,
  reset: () => void,
  status: 'idle' | 'pending' | 'success' | 'error'
} {
  const result = api.useMutation("post", "/quizzes/quiz/{quizId}/user/{userId}/reset-attempts");
  return {
    ...result,
    error: result.error ? (result.error.message || 'Failed to reset user quiz attempts') : null
  };
}

// --- Attempt Controller Hooks ---

// GET /quizzes/{quizId}/attempt/{attemptId}
export function useGetAttemptDetails(quizId: string, attemptId: string): {
  data: QuizAttemptResponse | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/attempt/{attemptId}", {
    params: { path: { quizId, attemptId } }
  }, { enabled: !!quizId && !!attemptId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch attempt details') : null,
    refetch: result.refetch
  };
}

// GET /quizzes/{quizId}/analytics
export function useQuizAnalytics(quizId: string): {
  data: {
    totalAttempts: number;
    submissions: number;
    passRate: number;
    averageScore: number;
  } | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/analytics", {
    params: { path: { quizId } }
  }, { enabled: !!quizId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch quiz analytics') : null,
    refetch: result.refetch
  };
}

// GET /quizzes/{quizId}/details
export function useQuizDetails(quizId: string): {
  data: {
    _id?: string | ObjectId;
    name: string;
    description: string;
    type: 'QUIZ';
    details?: {
      questionBankRefs: Array<{
        bankId: string;
        count: number;
        difficulty?: string[];
        tags?: string[];
        type?: string;
      }>;
      passThreshold: number;
      maxAttempts: number;
      quizType: 'DEADLINE' | 'NO_DEADLINE';
      releaseTime: Date;
      questionVisibility: number;
      deadline?: Date;
      approximateTimeToComplete: string;
      allowPartialGrading: boolean;
      allowHint: boolean;
      showCorrectAnswersAfterSubmission: boolean;
      showExplanationAfterSubmission: boolean;
      showScoreAfterSubmission: boolean;
    };
  } | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/details", {
    params: { path: { quizId } }
  }, { enabled: !!quizId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch quiz details') : null,
    refetch: result.refetch
  };
}

// GET /quizzes/{quizId}/performance
export function useQuizPerformance(quizId: string): {
  data: Array<{
    questionId: string;
    correctRate: number;
    averageScore: number;
  }> | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/performance", {
    params: { path: { quizId } }
  }, { enabled: !!quizId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch quiz performance') : null,
    refetch: result.refetch
  };
}

// Get /quizzes/{quizId}/results
export function useQuizResults(quizId: string): {
  data: Array<{
    studentId: string | ObjectId;
    attemptId: string | ObjectId;
    score: number;
    status: 'PENDING' | 'PASSED' | 'FAILED';
  }> | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/results", {
    params: { path: { quizId } }
  }, { enabled: !!quizId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch quiz results') : null,
    refetch: result.refetch
  };
}

export function useQuizSubmissions(quizId: string): {
  data: QuizSubmissionResponseUpdated[] | undefined,
  isLoading: boolean,
  error: string | null,
  refetch: () => void
} {
  const result = api.useQuery("get", "/quizzes/quiz/{quizId}/submissions", {
    params: { path: { quizId } }
  }, { enabled: !!quizId });

  return {
    data: result.data,
    isLoading: result.isLoading,
    error: result.error ? (result.error.message || 'Failed to fetch quiz submissions') : null,
    refetch: result.refetch
  };
}

